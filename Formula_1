section .data
    output  db 0             ; Variable output sin signo de tipo char
    t       db 0             ; Variable t de tipo char
    on_time dw 0             ; Variable on_time de tipo int

section .text
    global f1
    extern disp_binary, delay

f1:
    mov  al, 0              ; Inicializar t en 0

    cmp  al, 1              ; Comparar t con 1
    jge  end_loop_t         ; Si t >= 1, saltar al final del bucle

    mov  BYTE [output], 0x80 ; Asignar 0x80 a output

    mov  cx, 2              ; Inicializar i en 2

loop_i:
    cmp  cx, 512            ; Comparar i con 512
    jge  end_loop_i         ; Si i >= 512, saltar al final del bucle

    mov  word [on_time], 1000 ; Asignar 1000 a on_time
    push word [output]        ; Argumento: output
    call disp_binary          ; Llamar a la función disp_binary
    add  sp, 2                ; Ajustar puntero de pila

    mov  ax, [on_time]        ; Argumento: on_time
    call delay                ; Llamar a la función delay

    mov  al, BYTE [output]
    cbw                       ; Extender el signo de al a ax
    mov  bl, BYTE [cx]
    div  bl                   ; Dividir ax entre bl
    add  al, BYTE [output]    ; Sumar el resultado de la división a al
    mov  BYTE [output], al    ; Guardar el resultado en output

    shl  cx, 1                ; i = i * 2
    add  cx, 2                ; i = i + 2
    jmp  loop_i

end_loop_i:
    mov  BYTE [output], 0    ; Asignar 0 a output
    mov  word [on_time], 1000 ; Asignar 1000 a on_time

    push word [output]        ; Argumento: output
    call disp_binary          ; Llamar a la función disp_binary
    add  sp, 2                ; Ajustar puntero de pila

    mov  ax, [on_time]        ; Argumento: on_time
    call delay                ; Llamar a la función delay

end_loop_t:
    ret                       ; Retornar